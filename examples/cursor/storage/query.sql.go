// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package storage

import (
	"context"

	"encoding/base64"
	"encoding/json"
	"errors"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO authors (
    name, bio
) VALUES (
             $1, $2
         )
RETURNING id, name, bio, status, created_at`

type CreateAuthorParams struct {
	Name string      `json:"name"`
	Bio  pgtype.Text `json:"bio"`
}

// gql: Mutation
func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (Author, error) {
	row := q.db.QueryRow(ctx, createAuthor, arg.Name, arg.Bio)
	var i Author
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const listAuthors = `-- name: ListAuthors :many
SELECT cursor_pagination_source.* 
FROM (SELECT id, name, bio, status, created_at FROM authors) as cursor_pagination_source
WHERE $2='' or  (name > $3 OR (name = $3 AND (id > $4)))
ORDER BY name, id
LIMIT $1`

type ListAuthorsParams struct {
	Limit  int32  `json:"limit"`
	Cursor string `json:"cursor"`
}

// gql: Query
// paginated: cursor:name,id
func (q *Queries) ListAuthors(ctx context.Context, arg ListAuthorsParams) (AuthorConnection, error) {
	var cursor authorCursor
	if arg.Cursor != "" {
		cursorDec, err := base64.StdEncoding.DecodeString(arg.Cursor)
		if err != nil {
			return AuthorConnection{}, errors.New("failed to decode a cursor")
		}
		if err := json.Unmarshal(cursorDec, &cursor); err != nil {
			return AuthorConnection{}, errors.New("failed to unmarshal a cursor")
		}
	}
	rows, err := q.db.Query(ctx, listAuthors,
		arg.Limit+1,
		arg.Cursor,
		cursor.Name,
		cursor.ID,
	)
	if err != nil {
		return AuthorConnection{}, err
	}
	defer rows.Close()
	var items []Author
	for rows.Next() {
		var i Author
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Bio,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return AuthorConnection{}, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return AuthorConnection{}, err
	}
	connection := AuthorConnection{}
	connection.Edges = make([]AuthorEdge, len(items))
	hasNext := false
	if len(items) > int(arg.Limit) {
		hasNext = true
		items = items[:len(items)-1]
	}
	hasPrevious := false
	if arg.Cursor != "" {
		hasPrevious = true
	}
	connection.PageInfo = PageInfo{
		HasNextPage:     hasNext,
		HasPreviousPage: hasPrevious,
	}
	for i, item := range items {
		cursor := authorCursor{
			Name: item.Name,
			ID:   item.ID,
		}
		cursorJson, err := json.Marshal(cursor)
		if err != nil {
			return AuthorConnection{}, errors.New("failed to unmarshal a cursor")
		}
		cursorValue := base64.StdEncoding.EncodeToString(cursorJson)
		if i == 0 {
			connection.PageInfo.StartCursor = cursorValue
		}
		if i == len(items)-1 {
			connection.PageInfo.EndCursor = cursorValue
		}
		connection.Edges[i] = AuthorEdge{
			Node:   item,
			Cursor: cursorValue,
		}
	}
	return connection, nil
}
